package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"bitbucket.org/Southclaws/samp-objects-api/types"
	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
	"github.com/pkg/errors"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"
)

// AuthRequest represents the object POSTed to the /login endpoint in order to get a token
type AuthRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// AuthResponse represents the object returned on successful login
type AuthResponse struct {
	Message string `json:"message,omitempty"`
	Token   string `json:"token,omitempty"`
}

// SetupAuth creates a default root user if it does not already exist
func (app App) SetupAuth() {
	exists, err := app.Storage.UserExistsByName("root")
	if err != nil {
		logger.Fatal("failed to check for root user account existence")
	}

	if !exists {
		// Plaintext passwords are SHA'd on the client, bcrypt'd on the server
		// since this is the auto-generated root account, we're doing both here.
		password, err := GenerateRandomString(40)
		if err != nil {
			logger.Fatal("failed to create hash from generated bytes")
		}

		clientHash := fmt.Sprintf("%x", sha256.Sum256([]byte(password)))

		serverHash, err := bcrypt.GenerateFromPassword([]byte(clientHash), bcrypt.DefaultCost)
		if err != nil {
			logger.Fatal("failed to generate bcrypt from sha256")
		}

		if err = app.Storage.CreateUser(types.User{Username: "root", Email: "admin@samp-objects.com", Password: string(serverHash)}); err != nil {
			logger.Fatal("failed to create root user")
		}
		logger.Info("created new root account", zap.String("password", password))
	}
}

// AuthenticateLoginRequest is called for /login requests and authenticates the request body against
// the database
func (app *App) AuthenticateLoginRequest(r *http.Request) (success bool, err error) {
	var authRequest AuthRequest
	decoder := json.NewDecoder(r.Body)
	err = decoder.Decode(&authRequest)
	if err != nil {
		return
	}

	user, err := app.Storage.GetUserByName(authRequest.Username)
	if err != nil {
		return false, fmt.Errorf("database lookup failed: %v", err)
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(authRequest.Password)); err != nil {
		return false, err
	}

	return true, nil
}

// Authenticated is a middleware layer for requests that require authentication
func (app *App) Authenticated(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		logger.Debug("received authenticated request")
		token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
			}

			return []byte(app.config.AuthSecret), nil
		})
		if err != nil {
			WriteResponse(w, http.StatusInternalServerError,
				[]error{errors.Wrap(err, "failed to parse Authorization header")},
				map[string]interface{}{"headers": r.Header})
			return
		}

		if !token.Valid {
			WriteResponse(w, http.StatusUnauthorized, []error{errors.Wrap(err, "request failed authentication")}, nil)
			return
		}

		_, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			WriteResponse(w, http.StatusInternalServerError, []error{errors.New("failed to get token claim")}, nil)
		}

		logger.Debug("successfully handled authenticated request")

		next.ServeHTTP(w, r)
	})
}

// GenerateRandomBytes does what it says on the tin
// From https://elithrar.github.io/article/generating-secure-random-numbers-crypto-rand/ 2017-06-20
func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	// Note that err == nil only if we read len(b) bytes.
	if err != nil {
		return nil, err
	}

	return b, nil
}

// GenerateRandomString generates a string-valid byte slice, it's a base64 minus the equal signs
func GenerateRandomString(s int) (string, error) {
	b, err := GenerateRandomBytes(s)
	return strings.Trim(base64.URLEncoding.EncodeToString(b), "=/_-"), err
}

// LoggedIn is a dummy endpoint to check logged-in status
func LoggedIn(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	_, err := w.Write([]byte(`{"loggedIn": "yes!"}`))
	if err != nil {
		logger.Fatal("failed to write to response writer", zap.Error(err))
	}
}
