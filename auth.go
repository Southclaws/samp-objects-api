package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
	"github.com/gorilla/sessions"
	"github.com/pkg/errors"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"

	"bitbucket.org/Southclaws/samp-objects-api/types"
)

// AuthRequest represents the object POSTed to the /login endpoint in order to get a token
type AuthRequest struct {
	Username types.UserName `json:"username"`
	Password types.UserPass `json:"password"`
}

// AuthResponse represents the object returned on successful login
type AuthResponse struct {
	Token string `json:"token,omitempty"`
}

// SetupAuth creates a default root user if it does not already exist
func (app App) SetupAuth() {
	exists, err := app.Storage.UserExistsByName("root")
	if err != nil {
		logger.Fatal("failed to check for root user account existence")
	}

	if !exists {
		// Plaintext passwords are SHA'd on the client, bcrypt'd on the server
		// since this is the auto-generated root account, we're doing both here.
		password, err := GenerateRandomString(40)
		if err != nil {
			logger.Fatal("failed to create hash from generated bytes")
		}

		clientHash := fmt.Sprintf("%x", sha256.Sum256([]byte(password)))

		serverHash, err := bcrypt.GenerateFromPassword([]byte(clientHash), bcrypt.DefaultCost)
		if err != nil {
			logger.Fatal("failed to generate bcrypt from sha256")
		}

		if err = app.Storage.CreateUser(
			types.User{
				Username: types.UserName("root"),
				Email:    types.UserEmail("admin@samp-objects.com"),
				Password: types.UserPass(serverHash),
			}); err != nil {
			logger.Fatal("failed to create root user")
		}
		logger.Info("created new root account", zap.String("password", password))
	}
}

// Authenticated is a middleware layer for requests that require authentication
func (app *App) Authenticated(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
			}

			return []byte(app.config.AuthSecret), nil
		})
		if err != nil {
			WriteResponseError(w, http.StatusInternalServerError, errors.Wrap(err, "failed to parse Authorization header"))
			return
		}

		if !token.Valid {
			WriteResponseError(w, http.StatusUnauthorized, errors.Wrap(err, "request failed authentication"))
			return
		}

		_, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			WriteResponseError(w, http.StatusInternalServerError, errors.New("failed to get token claim"))
			return
		}

		session, err := app.Sessions.Get(r, UserSessionCookie)
		if err != nil {
			WriteResponseError(w, http.StatusInternalServerError, errors.New("failed to read session cookies"))
			return
		}

		authenticated, ok := session.Values["token"].(string)
		if !ok || authenticated == "" {
			WriteResponseError(w, http.StatusUnauthorized, errors.New("not authorized"))
			return
		}

		next.ServeHTTP(w, r)
	})
}

// GenerateRandomBytes does what it says on the tin
// From https://elithrar.github.io/article/generating-secure-random-numbers-crypto-rand/ 2017-06-20
func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	// Note that err == nil only if we read len(b) bytes.
	if err != nil {
		return nil, err
	}

	return b, nil
}

// GenerateRandomString generates a string-valid byte slice, it's a base64 minus the equal signs
func GenerateRandomString(s int) (string, error) {
	b, err := GenerateRandomBytes(s)
	return strings.Trim(base64.URLEncoding.EncodeToString(b), "=/_-"), err
}

// WriteToken writes a token response for a request, it also ensures the token is cached and stored
// as related to the user who made the request.
func (app App) WriteToken(w http.ResponseWriter, r *http.Request, session *sessions.Session) (err error) {
	token, err := app.newToken(time.Hour * 24)
	if err != nil {
		WriteResponseError(w, http.StatusInternalServerError, errors.Wrap(err, "failed to sign authentication token"))
		return
	}

	session.Values["token"] = token
	err = session.Save(r, w)
	if err != nil {
		WriteResponseError(w, http.StatusInternalServerError, errors.Wrap(err, "failed to store token to cookie"))
		return
	}

	payload, err := json.Marshal(&AuthResponse{Token: token})
	if err != nil {
		WriteResponseError(w, http.StatusInternalServerError, errors.Wrap(err, "failed to encode token payload"))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_, err = w.Write(payload)
	if err != nil {
		WriteResponseError(w, http.StatusInternalServerError, errors.Wrap(err, "failed to write token payload"))
		return
	}

	return
}

// newToken generates a JWT token and returns it as a string
func (app App) newToken(exp time.Duration) (token string, err error) {
	tokenObj := jwt.New(jwt.SigningMethodHS256)
	claims := tokenObj.Claims.(jwt.MapClaims)
	claims["exp"] = time.Now().Add(time.Hour * 24).Unix()
	token, err = tokenObj.SignedString([]byte(app.config.AuthSecret))
	return
}
