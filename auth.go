package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/dgrijalva/jwt-go"
	"github.com/dgrijalva/jwt-go/request"
	"go.uber.org/zap"
	"golang.org/x/crypto/bcrypt"
	"gopkg.in/mgo.v2/bson"
)

// SetupAuth creates a default root user if it does not already exist
func (app App) SetupAuth() {
	count, err := app.collection.Find(bson.M{"username": "root"}).Count()
	if err != nil {
		logger.Fatal("failed to execute find on root user")
	}

	if count == 0 {
		// Plaintext passwords are SHA'd on the client, bcrypt'd on the server
		// since this is the auto-generated root account, we're doing both here.
		password, err := GenerateRandomString(40)
		if err != nil {
			logger.Fatal("failed to create hash from generated bytes")
		}

		clientHash := fmt.Sprintf("%x", sha256.Sum256([]byte(password)))

		serverHash, err := bcrypt.GenerateFromPassword([]byte(clientHash), bcrypt.DefaultCost)
		if err != nil {
			logger.Fatal("failed to generate bcrypt from sha256")
		}

		if err = app.collection.Insert(AuthUser{Username: "root", Password: string(serverHash)}); err != nil {
			logger.Fatal("failed to create root user")
		}
		logger.Info("created new root account", zap.String("password", password))
	}
}

// AuthRequest represents the object POSTed to the /login endpoint in order to get a token
type AuthRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// AuthResponse represents the object returned on successful login
type AuthResponse struct {
	Message string `json:"message,omitempty"`
	Token   string `json:"token,omitempty"`
}

// AuthUser represents an API user with permission to access authenticated API endpoints
type AuthUser struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// AuthenticateLoginRequest is called for /login requests and authenticates the request body against
// the database
func (app *App) AuthenticateLoginRequest(r *http.Request) (success bool, err error) {
	var (
		ar AuthRequest
		au AuthUser
	)

	decoder := json.NewDecoder(r.Body)
	err = decoder.Decode(&ar)
	if err != nil {
		return
	}

	logger.Debug("received authenticate login request",
		zap.String("username", ar.Username),
		zap.String("password", ar.Password))

	err = app.collection.Find(bson.M{"username": ar.Username}).One(&au)
	if err != nil {
		return false, fmt.Errorf("database lookup failed: %v", err)
	}

	if err := bcrypt.CompareHashAndPassword([]byte(au.Password), []byte(ar.Password)); err != nil {
		return false, err
	}

	return true, nil
}

// Authenticated is a middleware layer for requests that require authentication
func (app *App) Authenticated(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		logger.Debug("received authenticated request")

		token, err := request.ParseFromRequest(r, request.AuthorizationHeaderExtractor, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
			}

			return []byte(app.config.AuthSecret), nil
		})
		if err != nil {
			logger.Error("failed to parse Authorization header",
				zap.Error(err),
				zap.Any("headers", r.Header))
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if !token.Valid {
			logger.Warn("request failed authentication",
				zap.Any("request", r))
			w.WriteHeader(http.StatusUnauthorized)
			return
		}

		claims, ok := token.Claims.(jwt.MapClaims)
		if !ok {
			logger.Warn("request failed to get token claim",
				zap.Any("request", r))
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		logger.Debug("obtained token claims",
			zap.Any("claims", claims))

		next.ServeHTTP(w, r)
	})
}

// GenerateRandomBytes does what it says on the tin
// From https://elithrar.github.io/article/generating-secure-random-numbers-crypto-rand/ 2017-06-20
func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	// Note that err == nil only if we read len(b) bytes.
	if err != nil {
		return nil, err
	}

	return b, nil
}

// GenerateRandomString generates a string-valid byte slice, it's a base64 minus the equal signs
func GenerateRandomString(s int) (string, error) {
	b, err := GenerateRandomBytes(s)
	return strings.Trim(base64.URLEncoding.EncodeToString(b), "=/_-"), err
}

// LoggedIn is a dummy endpoint to check logged-in status
func LoggedIn(w http.ResponseWriter, r *http.Request) {
	//
}
